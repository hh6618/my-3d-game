<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D 躲避射击游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #e2e8f0;
            cursor: none; /* Hide default cursor for better FPS experience */
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none;   /* Safari */
            -khtml-user-select: none;    /* Konqueror HTML */
            -moz-user-select: none;      /* Old versions of Firefox */
            -ms-user-select: none;       /* Internet Explorer/Edge */
            user-select: none;           /* Non-prefixed version, currently
                                            supported by Chrome, Edge, Opera and Firefox */
            -webkit-overflow-scrolling: touch; /* Enable smooth scrolling on iOS */
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* 确保背景覆盖整个容器 */
            background-color: #1a202c;
        }
        canvas {
            display: block;
            background-color: #333; /* Darker background for the game area */
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            width: 100%; /* Make canvas fill its parent container */
            height: 100%; /* Make canvas fill its parent container */
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
            font-size: 1.5rem;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            z-index: 10;
        }
        #game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
            display: none; /* Hidden by default */
            z-index: 20;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
        }
        #game-message button {
            margin-top: 20px;
            padding: 12px 25px;
            font-size: 1.2rem;
            font-weight: bold;
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        #game-message button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
        #game-message button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        /* 桌面端准星默认隐藏，在移动端始终隐藏 */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 2px;
            background-color: white;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
            z-index: 100; /* Ensure it's on top */
            display: none; /* 默认隐藏，JavaScript会根据鼠标锁定状态控制显示 */
        }

        /* --- 攻击方向指示器样式 --- */
        #hit-indicators {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 50; /* Above other UI elements */
        }
        .hit-indicator {
            position: absolute;
            width: 30px; /* Size of the indicator */
            height: 30px;
            background-color: rgba(255, 0, 0, 0.7); /* Red, semi-transparent */
            border-radius: 50%; /* Make it a circle */
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.1s ease-out; /* For fading out */
        }
        /* Positioning the indicators */
        #hit-front { top: 10%; left: 50%; transform: translateX(-50%); }
        #hit-back { bottom: 10%; left: 50%; transform: translateX(-50%); }
        #hit-left { left: 10%; top: 50%; transform: translateY(-50%); }
        #hit-right { right: 10%; top: 50%; transform: translateY(-50%); }

        /* --- 武器UI样式 --- */
        #weapon-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }
        #weapon-icon {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover; /* Ensures image covers the area */
            background-color: #4a5568; /* Placeholder background */
        }
        #bullet-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        #bullet-count {
            font-size: 2.2rem;
            font-weight: bold;
            color: #fff;
        }
        #weapon-name {
            font-size: 1.2rem;
            color: #cbd5e0;
        }

        /* --- 移动端触控 UI 样式 --- */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px; /* 控制区域的高度 */
            display: flex; /* 默认隐藏，JavaScript 会根据 isMobile 来显示 */
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px;
            box-sizing: border-box;
            z-index: 200; /* 确保在最顶层 */
            pointer-events: none; /* 允许点击穿透，只让子元素响应事件 */
            background: linear-gradient(to top, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%); /* 底部渐变背景 */
            /* 默认隐藏，JS 决定是否显示 */
            display: none;
        }

        #joystick-area, #shoot-area {
            width: 120px; /* 摇杆/射击区大小 */
            height: 120px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            pointer-events: auto; /* 允许自身响应事件 */
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            touch-action: none; /* 防止浏览器默认的触控行为，如滚动 */
        }

        #joystick-handle {
            width: 50px; /* 摇杆手柄大小 */
            height: 50px;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            position: absolute; /* 相对于父级摇杆区域定位 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* 居中 */
            transition: none; /* 初始无过渡 */
        }

        #shoot-area {
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            display: flex;
            flex-direction: column; /* 允许内部元素垂直排列 */
            align-items: center;
            justify-content: center;
            gap: 5px; /* 射击和冲刺/跳跃按钮之间的间距 */
        }

        #dash-button, #jump-button {
            width: 80px; /* 按钮大小 */
            height: 40px;
            background-color: rgba(76, 175, 80, 0.7); /* 绿色 */
            color: white;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            font-weight: bold;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            touch-action: none;
            cursor: pointer; /* 触控设备上无效但桌面调试时可见 */
        }

        #dash-button:active, #jump-button:active, #shoot-area:active {
            background-color: rgba(76, 175, 80, 0.9); /* 按下时的颜色 */
            transform: scale(0.95); /* 按下时稍微缩小 */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="health-display">生命值: 100 (复活: 3)</div>
            <div id="score-display">分数: 0</div>
            <div id="wave-display">波次: 1 / 5 (敌人: 0/5)</div>
        </div>
        <div id="game-message">
            <span id="message-text">游戏结束！</span><br>
            <button id="restart-button">重新开始</button>
        </div>
        <div id="crosshair"></div>
        <div id="hit-indicators">
            <div id="hit-front" class="hit-indicator"></div>
            <div id="hit-back" class="hit-indicator"></div>
            <div id="hit-left" class="hit-indicator"></div>
            <div id="hit-right" class="hit-indicator"></div>
        </div>

        <div id="weapon-display">
            <img id="weapon-icon" src="https://placehold.co/60x60/0077ff/ffffff?text=Pistol" alt="Weapon Icon">
            <div id="bullet-info">
                <span id="bullet-count">8/8 (∞)</span>
                <span id="weapon-name">手枪</span>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="mobile-controls">
            <div id="joystick-area">
                <div id="joystick-handle"></div>
            </div>

            <div id="shoot-area">
                <div style="flex-grow: 1; display: flex; align-items: center; justify-content: center; width: 100%;">
                    <div style="display: flex; gap: 10px; position: absolute; top: 10px; right: 20px;">
                        <button id="jump-button">跳跃</button>
                        <button id="dash-button">冲刺</button>
                    </div>
                    <span>射击</span>
                </div>
            </div>
        </div>
        </div>

    <script type="module">
        // --- 全局变量和初始化 ---
        let scene, camera, renderer;
        let player;
        const playerSpeed = 0.15;
        let score = 0;

        const allCharacters = [];
        const enemies = [];

        const playerBullets = [];
        const enemyBullets = [];
        const obstacles = [];
        let temporaryObstacles = [];

        const bulletSpeed = 0.8;
        const enemyBulletSpeed = 0.3;
        let lastEnemySpawnTime = 0;

        const healthDisplay = document.getElementById('health-display');
        const scoreDisplay = document.getElementById('score-display');
        const gameMessage = document.getElementById('game-message');
        const messageText = document.getElementById('message-text');
        const restartButton = document.getElementById('restart-button');
        const crosshair = document.getElementById('crosshair');
        const waveDisplay = document.getElementById('wave-display');

        const hitIndicatorFront = document.getElementById('hit-front');
        const hitIndicatorBack = document.getElementById('hit-back');
        const hitIndicatorLeft = document.getElementById('hit-left');
        const hitIndicatorRight = document.getElementById('hit-right');

        const weaponIcon = document.getElementById('weapon-icon');
        const bulletCountDisplay = document.getElementById('bullet-count');
        const weaponNameDisplay = document.getElementById('weapon-name');

        let isGameOver = false;
        let isGamePaused = false;

        const waveDefinitions = [
            { waveNumber: 1, enemyCount: 5, spawnRateMultiplier: 1.0 },
            { waveNumber: 2, enemyCount: 7, spawnRateMultiplier: 1.2 },
            { waveNumber: 3, enemyCount: 10, spawnRateMultiplier: 1.5 },
            { waveNumber: 4, enemyCount: 12, spawnRateMultiplier: 1.8 },
            { waveNumber: 5, enemyCount: 15, spawnRateMultiplier: 2.0 },
            { waveNumber: 6, enemyCount: 18, spawnRateMultiplier: 2.2 },
            { waveNumber: 7, enemyCount: 20, spawnRateMultiplier: 2.5 },
            { waveNumber: 8, enemyCount: 25, spawnRateMultiplier: 2.8 },
            { waveNumber: 9, enemyCount: 30, spawnRateMultiplier: 3.0 },
            { waveNumber: 10, enemyCount: 35, spawnRateMultiplier: 3.2 }
        ];
        let currentWaveIndex = 0;
        let enemiesSpawnedInWave = 0;
        let enemiesDefeatedInWave = 0;
        const enemySpawnIntervalBase = 2000;

        const keys = {
            w: false, a: false, s: false, d: false,
            space: false,
            c: false,
            r: false
        };

        let isMouseDown = false;
        let isRightMouseDown = false;
        let lastPlayerShotTime = 0;
        const mouseSensitivity = 0.002;

        const gravity = -0.02;
        const jumpForce = 0.5;
        const playerGroundY = 0.5;

        const dashDuration = 200;
        const dashCooldown = 1000;
        const playerDashSpeed = 0.5;
        const dashDirection = new THREE.Vector3();

        const weaponDefinitions = {
            pistol: {
                name: "手枪",
                clipSize: 8,
                fireRate: 500,
                reloadTime: 2000,
                weaponImage: "https://placehold.co/60x60/0077ff/ffffff?text=Pistol",
                bulletDamage: 10
            },
            mp5: {
                name: "MP5冲锋枪",
                clipSize: 30,
                fireRate: 100,
                reloadTime: 2500,
                weaponImage: "https://placehold.co/60x60/ff0000/ffffff?text=MP5",
                bulletDamage: 10
            },
            sniper: {
                name: "M56狙击枪",
                clipSize: 5,
                fireRate: 1500,
                reloadTime: 3000,
                weaponImage: "https://placehold.co/60x60/800080/ffffff?text=Sniper",
                bulletDamage: 50
            },
            f7: {
                name: "F-7",
                clipSize: 100,
                fireRate: 100,
                reloadTime: 2500,
                weaponImage: "https://placehold.co/60x60/FF4500/FFFFFF?text=F-7",
                bulletDamage: 20,
                playerHealthCapIncrease: 100,
                enemyHealthRegenPerShot: 10
            },
            ve8: {
                name: "VE-8",
                clipSize: 50,
                fireRate: 150,
                reloadTime: 2000,
                weaponImage: "https://placehold.co/60x60/FF00FF/000000?text=VE-8",
                bulletDamage: 1,
                playerHealthRegen: 50,
                enemyForbidden: true
            },
            kird: {
                name: "KIRD",
                clipSize: 60,
                fireRate: 150,
                reloadTime: 2800,
                weaponImage: "https://placehold.co/60x60/00FFFF/000000?text=KIRD",
                bulletDamage: 25,
                piercing: true
            },
            hv5: {
                name: "HV5",
                clipSize: 20,
                fireRate: 200,
                reloadTime: 2500,
                weaponImage: "https://placehold.co/60x60/FFA500/FFFFFF?text=HV5",
                bulletDamage: 25,
                explosive: true
            },
            dr18: {
                name: "DR-18",
                clipSize: 600,
                fireRate: 100,
                reloadTime: 3000,
                weaponImage: "https://placehold.co/60x60/4B0082/FFFFFF?text=DR-18",
                bulletDamage: 1000,
                piercing: true,
                enemyVision: true
            },
            mcv7: {
                name: "M-cv7",
                clipSize: 500,
                fireRate: 80,
                reloadTime: 3500,
                weaponImage: "https://placehold.co/60x60/FFD700/000000?text=M-cv7",
                bulletDamage: 50,
                playerPiercing: true,
                healthCapIncreaseOnKill: 50,
                obstacleOnKillCount: 3
            }
        };

        const explosionRadius = 3;
        const explosionDamage = 50;

        let weaponBox;
        const reviveDuration = 1500;

        const obstacleData = [
            { x: 5, z: 5, width: 4, depth: 4, height: 3 },
            { x: -8, z: -8, width: 3, depth: 6, height: 4 },
            { x: 0, z: -12, width: 6, depth: 2, height: 3.5 },
            { x: -15, z: 5, width: 2, depth: 2, height: 5 },
            { x: 12, z: -3, width: 2, depth: 8, height: 3 },
            { x: -10, z: 10, width: 5, depth: 3, height: 2.5 },
            { x: 7, z: -15, width: 3, depth: 3, height: 6 },
            { x: -20, z: -18, width: 4, depth: 4, height: 3 },
            { x: 18, z: 18, width: 2, depth: 6, height: 4 },
            { x: -5, z: 15, width: 3, depth: 3, height: 3 },
            { x: 15, z: -10, width: 2, depth: 5, height: 4.5 },
            { x: -18, z: -5, width: 6, depth: 2, height: 3 },
            { x: 20, z: 0, width: 2, depth: 4, height: 5 },
            { x: 0, z: 20, width: 8, depth: 2, height: 2.5 },
            { x: -12, z: -12, width: 3, depth: 3, height: 4 },
            { x: 10, z: 10, width: 4, depth: 2, height: 3.5 },
            { x: -22, z: 0, width: 3, depth: 3, height: 3.5 },
            { x: 22, z: 0, width: 3, depth: 3, height: 3.5 },
            { x: 0, z: 22, width: 3, depth: 3, height: 3.5 },
            { x: 0, z: -22, width: 3, depth: 3, height: 3.5 },
            { x: -10, z: -5, width: 2, depth: 2, height: 2.5 },
            { x: 10, z: 5, width: 2, depth: 2, height: 2.5 },
            { x: -5, z: 10, width: 2, depth: 2, height: 2.5 },
            { x: 5, z: -10, width: 2, depth: 2, height: 2.5 },
            { x: -20, z: -5, width: 3, depth: 8, height: 3 },
            { x: 20, z: 5, width: 3, depth: 8, height: 3 },
            { x: 5, z: -20, width: 8, depth: 3, height: 3 },
            { x: -5, z: 20, width: 8, depth: 3, height: 3 },
            { x: 15, z: 15, width: 4, depth: 4, height: 4 },
            { x: -15, z: -15, width: 4, depth: 4, height: 4 },
            { x: 0, z: 0, width: 2, depth: 2, height: 2 },
            { x: 10, z: -18, width: 2, depth: 2, height: 5 },
            { x: -10, z: 18, width: 2, depth: 2, height: 5 }
        ];

        // --- 触控变量 ---
        let isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent); // 更全面的移动设备判断
        let touchStartX = 0;
        let touchStartY = 0;
        let joystickActive = false;
        let joystickX = 0; // 摇杆的相对X位置
        let joystickY = 0; // 摇杆的相对Y位置
        const joystickArea = document.getElementById('joystick-area');
        const joystickHandle = document.getElementById('joystick-handle');

        let shootTouchId = -1; // 用于跟踪射击触摸点的ID
        let lastTouchX = 0; // 用于视角旋转的上次触摸点
        let lastTouchY = 0;
        const shootArea = document.getElementById('shoot-area');
        const mobileControls = document.getElementById('mobile-controls'); // 获取触控 UI 容器

        const jumpButton = document.getElementById('jump-button'); // 跳跃按钮
        const dashButton = document.getElementById('dash-button'); // 冲刺按钮


        // --- 碰撞检测辅助函数 ---
        function isCollidingWithObstacles(object, obstacles) {
            const objectBox = new THREE.Box3().setFromObject(object);
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (objectBox.intersectsBox(obstacleBox)) {
                    return true;
                }
            }
            return false;
        }

        function moveAndCollide(object, deltaX, deltaZ, obstacles) {
            let originalX = object.position.x;
            let originalZ = object.position.z;

            object.position.x += deltaX;
            object.updateMatrixWorld();
            if (isCollidingWithObstacles(object, obstacles)) {
                object.position.x = originalX;
                object.updateMatrixWorld();
            }

            object.position.z += deltaZ;
            object.updateMatrixWorld();
            if (isCollidingWithObstacles(object, obstacles)) {
                object.position.z = originalZ;
                object.updateMatrixWorld();
            }
        }

        function getSafeRespawnPosition() {
            const boundary = 24;
            const minDistanceToCharacters = 8;
            const maxAttempts = 50;

            for (let i = 0; i < maxAttempts; i++) {
                const x = (Math.random() * 2 - 1) * boundary;
                const z = (Math.random() * 2 - 1) * boundary;
                const testPosition = new THREE.Vector3(x, playerGroundY, z);

                const tempMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1));
                tempMesh.position.copy(testPosition);
                tempMesh.position.y = 0.5;

                let isSafe = true;
                for (const char of allCharacters) {
                    if (!char.isDead && char.mesh.position.distanceTo(testPosition) < minDistanceToCharacters) {
                        isSafe = false;
                        break;
                    }
                }

                if (isSafe && isCollidingWithObstacles(tempMesh, obstacles)) {
                    isSafe = false;
                }

                if (isSafe) {
                    return testPosition;
                }
            }
            console.warn("Could not find a completely safe respawn position. Using default.");
            return new THREE.Vector3(0, playerGroundY, 0);
        }

        // --- 初始化场景 ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x282c34);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0.5, 0);

            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            
            // 移动设备性能优化：降低像素比
            if (isMobile) {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 0.8)); // 移动设备像素比最大设置为0.8
                console.log('Mobile device detected, setting pixel ratio to', Math.min(window.devicePixelRatio, 0.8));
            } else {
                renderer.setPixelRatio(window.devicePixelRatio); // 桌面端保持原有像素比
            }
            renderer.setSize(window.innerWidth, window.innerHeight);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            const planeGeometry = new THREE.PlaneGeometry(50, 50);
            const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x666666, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
            const playerMaterial = new THREE.MeshBasicMaterial({ visible: false });

            player = {
                mesh: new THREE.Mesh(playerGeometry, playerMaterial),
                type: 'player',
                maxHealth: 100,
                health: 100,
                maxRevives: 3,
                revivesRemaining: 3,
                isDead: false,
                isReviving: false,
                lastDeathTime: 0,
                velocityY: 0,
                isDashing: false,
                dashStartTime: 0,
                lastDashTime: 0,
                playerWeapons: [],
                selectedWeaponIndex: 0,
                currentWeapon: null,
                lastShotTime: 0,
                currentTarget: null,
                isAimingDR5: false,
                mcv7Kills: 0
            };

            player.mesh.position.set(0, playerGroundY, 0);
            scene.add(player.mesh);
            player.mesh.add(camera);

            player.playerWeapons.push({ ...weaponDefinitions.pistol, currentClipBullets: weaponDefinitions.pistol.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.mp5, currentClipBullets: weaponDefinitions.mp5.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.sniper, currentClipBullets: weaponDefinitions.sniper.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.f7, currentClipBullets: weaponDefinitions.f7.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.ve8, currentClipBullets: weaponDefinitions.ve8.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.kird, currentClipBullets: weaponDefinitions.kird.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.hv5, currentClipBullets: weaponDefinitions.hv5.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.dr18, currentClipBullets: weaponDefinitions.dr18.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.mcv7, currentClipBullets: weaponDefinitions.mcv7.clipSize, isReloading: false, lastReloadTime: 0 });

            player.selectedWeaponIndex = 0;
            player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];

            allCharacters.push(player);

            const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
            const boxMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            weaponBox = new THREE.Mesh(boxGeometry, boxMaterial);
            weaponBox.position.set(10, 1, -10);
            scene.add(weaponBox);

            const obstacleMaterial = new THREE.MeshPhongMaterial({ color: 0x4a4a4a });
            obstacleData.forEach(data => {
                const geometry = new THREE.BoxGeometry(data.width, data.height, data.depth);
                const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
                obstacle.position.set(data.x, data.height / 2, data.z);
                scene.add(obstacle);
                obstacles.push(obstacle);
            });

            window.addEventListener('resize', onWindowResize); // 确保在 init 最后调用一次
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('contextmenu', (event) => event.preventDefault());
            restartButton.addEventListener('click', restartGame);

            updateUI();
            updateWeaponUI();

            startWave(0);

            // Request pointer lock for better first-person experience (Desktop only)
            const gameCanvas = document.getElementById('gameCanvas');
            gameCanvas.requestPointerLock = gameCanvas.requestPointerLock || gameCanvas.mozRequestPointerLock;

            if (!isMobile) { // 只有在非移动设备上才启用鼠标锁定
                gameCanvas.onclick = function() {
                    if (!isGamePaused) {
                        gameCanvas.requestPointerLock();
                    }
                };
                document.addEventListener('pointerlockchange', lockChangeAlert, false);
                document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
            } else {
                // 移动设备上隐藏准星，因为没有鼠标锁定
                crosshair.style.display = 'none';
                mobileControls.style.display = 'flex'; // 在移动设备上显示触控 UI

                // 移动设备上的全屏请求 (需要在用户交互后触发)
                gameCanvas.addEventListener('touchstart', function requestMobileFullscreen() {
                    if (!isGamePaused) {
                        if (gameCanvas.requestFullscreen) {
                            gameCanvas.requestFullscreen();
                        } else if (gameCanvas.webkitRequestFullscreen) { /* Safari */
                            gameCanvas.webkitRequestFullscreen();
                        } else if (gameCanvas.mozRequestFullScreen) { /* Firefox */
                            gameCanvas.mozRequestFullScreen();
                        } else if (gameCanvas.msRequestFullscreen) { /* IE/Edge */
                            gameCanvas.msRequestFullscreen();
                        }
                    }
                    // 移除事件监听器，确保只触发一次或根据需要再次添加
                    gameCanvas.removeEventListener('touchstart', requestMobileFullscreen);
                }, { once: true });


                // --- 移动端触控事件监听 ---
                // 摇杆控制移动
                joystickArea.addEventListener('touchstart', handleJoystickStart, {passive: false});
                joystickArea.addEventListener('touchmove', handleJoystickMove, {passive: false});
                joystickArea.addEventListener('touchend', handleJoystickEnd, {passive: false});
                joystickArea.addEventListener('touchcancel', handleJoystickEnd, {passive: false});

                // 射击区域控制视角和射击
                shootArea.addEventListener('touchstart', handleShootStart, {passive: false});
                shootArea.addEventListener('touchmove', handleShootMove, {passive: false});
                shootArea.addEventListener('touchend', handleShootEnd, {passive: false});
                shootArea.addEventListener('touchcancel', handleShootEnd, {passive: false});
            
                // 跳跃按钮
                jumpButton.addEventListener('touchstart', handleJumpStart, {passive: false});
                jumpButton.addEventListener('touchend', handleJumpEnd, {passive: false});

                // 冲刺按钮
                dashButton.addEventListener('touchstart', handleDashStart, {passive: false});
                dashButton.addEventListener('touchend', handleDashEnd, {passive: false});
            }

            function lockChangeAlert() {
                if (document.pointerLockElement === gameCanvas ||
                    document.mozPointerLockElement === gameCanvas) {
                    console.log('The pointer lock is engaged.');
                    crosshair.style.display = 'block';
                } else {
                    console.log('The pointer lock is released.');
                    crosshair.style.display = 'none';
                }
            }

            animate();
            onWindowResize(); // Initial resize to set up camera and renderer
        }

        // --- 触控事件处理函数 ---

        // 摇杆移动逻辑
        function handleJoystickStart(event) {
            event.preventDefault(); // 阻止默认的滚动/缩放行为
            if (isGamePaused || player.isDead) return;

            const touch = event.changedTouches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            joystickActive = true;
            joystickHandle.style.transition = 'none'; // 移除过渡，让摇杆立即响应
            // 设置摇杆手柄的初始位置为触摸点
            joystickHandle.style.left = `${(touch.clientX - joystickArea.getBoundingClientRect().left)}px`;
            joystickHandle.style.top = `${(touch.clientY - joystickArea.getBoundingClientRect().top)}px`;
            joystickHandle.style.transform = 'translate(-50%, -50%)'; // 保持居中
        }

        function handleJoystickMove(event) {
            event.preventDefault(); // 阻止默认的滚动/缩放行为
            if (isGamePaused || player.isDead || !joystickActive) return;

            const touch = event.changedTouches[0];
            const areaRect = joystickArea.getBoundingClientRect();
            const centerX = areaRect.left + areaRect.width / 2;
            const centerY = areaRect.top + areaRect.height / 2;

            const deltaX = touch.clientX - centerX;
            const deltaY = touch.clientY - centerY;

            const maxRadius = areaRect.width / 2 - joystickHandle.offsetWidth / 2;
            const distance = Math.min(maxRadius, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
            const angle = Math.atan2(deltaY, deltaX);

            joystickX = distance * Math.cos(angle);
            joystickY = distance * Math.sin(angle);

            // 限制摇杆手柄在区域内
            joystickHandle.style.left = `calc(50% + ${joystickX}px)`;
            joystickHandle.style.top = `calc(50% + ${joystickY}px)`;
        }

        function handleJoystickEnd(event) {
            event.preventDefault(); // 阻止默认行为
            if (!joystickActive) return;

            joystickActive = false;
            joystickX = 0;
            joystickY = 0;
            // 摇杆手柄回到中心
            joystickHandle.style.transition = 'left 0.1s ease-out, top 0.1s ease-out, transform 0.1s ease-out';
            joystickHandle.style.left = '50%';
            joystickHandle.style.top = '50%';
        }

        // 射击和视角控制逻辑
        function handleShootStart(event) {
            event.preventDefault();
            if (isGamePaused || player.isDead) return;

            // 检查是否是新的触摸点用于射击
            let touchFound = false;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (shootTouchId === -1) { // 找到第一个未被占用的触摸点
                    shootTouchId = event.changedTouches[i].identifier;
                    touchFound = true;
                    lastTouchX = event.changedTouches[i].clientX;
                    lastTouchY = event.changedTouches[i].clientY;
                    break;
                }
            }
            if (!touchFound) return; // 没有新的触摸点可用于射击

            isMouseDown = true; // 模拟鼠标左键按下，触发射击
        }

        function handleShootMove(event) {
            event.preventDefault();
            if (isGamePaused || player.isDead || shootTouchId === -1) return;

            let currentTouch = null;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === shootTouchId) {
                    currentTouch = event.changedTouches[i];
                    break;
                }
            }
            if (!currentTouch) return;

            const movementX = currentTouch.clientX - lastTouchX;
            const movementY = currentTouch.clientY - lastTouchY;

            player.mesh.rotation.y -= movementX * mouseSensitivity;
            camera.rotation.x -= movementY * mouseSensitivity;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

            lastTouchX = currentTouch.clientX;
            lastTouchY = currentTouch.clientY;
        }

        function handleShootEnd(event) {
            event.preventDefault();
            if (isGamePaused || player.isDead) return;

            let touchEnded = false;
            for (let i = 0; i < event.changedTouches.length; i++) {
                if (event.changedTouches[i].identifier === shootTouchId) {
                    touchEnded = true;
                    break;
                }
            }
            if (!touchEnded) return;

            isMouseDown = false; // 模拟鼠标左键抬起
            shootTouchId = -1; // 重置触摸点ID
        }

        // 跳跃按钮逻辑
        function handleJumpStart(event) {
            event.preventDefault();
            if (isGamePaused || player.isDead) return;
            if (player.mesh.position.y <= playerGroundY + 0.01) {
                player.velocityY = jumpForce;
            }
        }
        function handleJumpEnd(event) {
            event.preventDefault();
            // 可以不执行任何操作，或者如果跳跃是按住持续跳跃则在这里停止
        }

        // 冲刺按钮逻辑
        function handleDashStart(event) {
            event.preventDefault();
            if (isGamePaused || player.isDead) return;
            if (!player.isDashing && Date.now() - player.lastDashTime > dashCooldown) {
                player.isDashing = true;
                player.dashStartTime = Date.now();
                camera.getWorldDirection(dashDirection);
                dashDirection.y = 0;
                dashDirection.normalize();
                player.lastDashTime = Date.now();
            }
        }
        function handleDashEnd(event) {
            event.preventDefault();
            // 冲刺是瞬间的，松开按钮不会立即停止冲刺，除非时间到了
        }


        // --- 窗口大小调整 ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 键盘事件处理 ---
        function onKeyDown(event) {
            if (isGamePaused || isMobile) return; // 移动设备禁用键盘输入
            if (player.isDead) { return; }

            switch (event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space':
                    if (player.mesh.position.y <= playerGroundY + 0.01) {
                        keys.space = true;
                        player.velocityY = jumpForce;
                    }
                    break;
                case 'KeyC':
                    keys.c = true;
                    if (!player.isDashing && Date.now() - player.lastDashTime > dashCooldown) {
                        player.isDashing = true;
                        player.dashStartTime = Date.now();
                        camera.getWorldDirection(dashDirection);
                        dashDirection.y = 0;
                        dashDirection.normalize();
                        player.lastDashTime = Date.now();
                    }
                    break;
                case 'KeyR':
                    keys.r = true;
                    if (!player.currentWeapon.isReloading && player.currentWeapon.currentClipBullets < player.currentWeapon.clipSize) {
                        reloadWeapon(player);
                    }
                    break;
                case 'Digit1':
                    if (player.selectedWeaponIndex !== 0) {
                        player.selectedWeaponIndex = 0;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                    }
                    break;
                case 'Digit2':
                    if (player.selectedWeaponIndex !== 1) {
                        player.selectedWeaponIndex = 1;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                    }
                    break;
                case 'Digit3':
                    if (player.selectedWeaponIndex !== 2) {
                        player.selectedWeaponIndex = 2;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                    }
                    break;
                case 'Digit4':
                    if (player.selectedWeaponIndex !== 3) {
                        player.selectedWeaponIndex = 3;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                        if (!player.currentWeapon.enemyVision) {
                            player.isAimingDR5 = false;
                        }
                    }
                    break;
                case 'Digit5':
                    if (player.selectedWeaponIndex !== 4) {
                        player.selectedWeaponIndex = 4;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                        player.bulletsFiredSinceLastRegen = 0;
                    }
                    break;
                case 'Digit6':
                    if (player.selectedWeaponIndex !== 5) {
                        player.selectedWeaponIndex = 5;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                    }
                    break;
                case 'Digit7':
                    if (player.selectedWeaponIndex !== 6) {
                        player.selectedWeaponIndex = 6;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                    }
                    break;
                case 'Digit8':
                    if (player.selectedWeaponIndex !== 7) {
                        player.selectedWeaponIndex = 7;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                        if (!player.currentWeapon.enemyVision) {
                            player.isAimingDR5 = false;
                        }
                    }
                    break;
                case 'Digit9':
                    if (player.selectedWeaponIndex !== 8) {
                        player.selectedWeaponIndex = 8;
                        player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                        updateWeaponUI();
                        player.lastShotTime = 0;
                        if (!player.currentWeapon.enemyVision) {
                            player.isAimingDR5 = false;
                        }
                    }
                    break;
                case 'KeyQ':
                    player.selectedWeaponIndex = (player.selectedWeaponIndex + 1) % player.playerWeapons.length;
                    player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];
                    updateWeaponUI();
                    player.lastShotTime = 0;
                    if (!player.currentWeapon.enemyVision) {
                        player.isAimingDR5 = false;
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            if (isGamePaused || isMobile) return; // 移动设备禁用键盘输入
            if (player.isDead) { return; }
            switch (event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyD': keys.d = false; break;
                case 'Space': keys.space = false; break;
                case 'KeyC': keys.c = false; break;
                case 'KeyR': keys.r = false; break;
            }
        }

        // --- 鼠标事件处理 ---
        function onMouseMove(event) {
            if (isGamePaused || document.pointerLockElement !== gameCanvas || isMobile) return; // 移动设备禁用鼠标控制
            if (player.isDead) { return; }

            const movementX = event.movementX || event.mozMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || 0;

            player.mesh.rotation.y -= movementX * mouseSensitivity;
            camera.rotation.x -= movementY * mouseSensitivity;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        function onMouseDown(event) {
            if (isGamePaused || isMobile) return; // 移动设备禁用鼠标控制
            if (player.isDead) { return; }
            if (event.button === 0) { // Left click
                isMouseDown = true;
            } else if (event.button === 2) { // Right click
                if (player.currentWeapon.enemyVision) {
                    isRightMouseDown = true;
                    player.isAimingDR5 = true;
                }
            }
        }

        function onMouseUp(event) {
            if (isGamePaused || isMobile) return; // 移动设备禁用鼠标控制
            if (player.isDead) { return; }
            if (event.button === 0) { // Left click
                isMouseDown = false;
            } else if (event.button === 2) { // Right click
                isRightMouseDown = false;
                player.isAimingDR5 = false;
            }
        }

        // --- 游戏逻辑更新 ---
        function update() {
            if (isGameOver || isGamePaused) return;

            const currentTime = Date.now();

            // --- Update Player ---
            player.velocityY += gravity;
            player.mesh.position.y += player.velocityY;
            if (player.mesh.position.y < playerGroundY) {
                player.mesh.position.y = playerGroundY;
                player.velocityY = 0;
            }

            if (player.isDead) {
                player.isDashing = false;
                keys.w = keys.a = keys.s = keys.d = keys.space = keys.c = false;
                isMouseDown = false;
            } else {
                // Player Dash Logic
                if (player.isDashing) {
                    const elapsedDashTime = currentTime - player.dashStartTime;
                    if (elapsedDashTime < dashDuration) {
                        const dashMoveX = dashDirection.x * playerDashSpeed;
                        const dashMoveZ = dashDirection.z * playerDashSpeed;
                        moveAndCollide(player.mesh, dashMoveX, dashMoveZ, obstacles);
                    } else {
                        player.isDashing = false;
                    }
                }

                // Player Movement (键盘或摇杆控制)
                if (!player.isDashing) {
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    forward.y = 0;
                    forward.normalize();

                    const right = new THREE.Vector3();
                    right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                    right.normalize();

                    let moveX = 0;
                    let moveZ = 0;

                    if (!isMobile) { // 桌面端键盘控制
                        if (keys.w) { moveX += forward.x; moveZ += forward.z; }
                        if (keys.s) { moveX -= forward.x; moveZ -= forward.z; }
                        if (keys.a) { moveX -= right.x; moveZ -= right.z; }
                        if (keys.d) { moveX += right.x; moveZ += right.z; }
                    } else { // 移动端摇杆控制
                        if (joystickActive && (Math.abs(joystickX) > 5 || Math.abs(joystickY) > 5)) { // 增加一个小的死区
                            // 将摇杆的 (joystickX, joystickY) 映射到相对于玩家朝向的 (moveX, moveZ)
                            // 注意摇杆的Y轴通常是上下，对应Three.js的Z轴（深度）
                            // 摇杆的X轴通常是左右，对应Three.js的X轴（宽度）

                            const moveDirection = new THREE.Vector3();
                            // forward.multiplyScalar(-joystickY) 是错误的，应该是根据摇杆Y方向决定是向前还是向后
                            // right.multiplyScalar(joystickX) 是错误的，应该是根据摇杆X方向决定是向左还是向右
                            
                            // 摇杆 Y (上下) -> 对应玩家前后移动
                            // 如果 joystickY < 0 (摇杆向上推) -> 玩家向前
                            // 如果 joystickY > 0 (摇杆向下推) -> 玩家向后
                            moveDirection.addScaledVector(forward, -joystickY);

                            // 摇杆 X (左右) -> 对应玩家左右平移
                            // 如果 joystickX > 0 (摇杆向右推) -> 玩家向右平移
                            // 如果 joystickX < 0 (摇杆向左推) -> 玩家向左平移
                            moveDirection.addScaledVector(right, joystickX);
                            
                            moveDirection.y = 0; // 确保只在XZ平面移动
                            moveDirection.normalize(); // 归一化以防止对角线加速

                            moveX = moveDirection.x;
                            moveZ = moveDirection.z;
                        }
                    }

                    const finalMoveX = moveX * playerSpeed;
                    const finalMoveZ = moveZ * playerSpeed;

                    moveAndCollide(player.mesh, finalMoveX, finalMoveZ, obstacles);

                    const boundary = 24;
                    player.mesh.position.x = Math.max(-boundary, Math.min(boundary, player.mesh.position.x));
                    player.mesh.position.z = Math.max(-boundary, Math.min(boundary, player.mesh.position.z));
                }

                // Player Shooting Logic (General and VE-8 specific health regen)
                if (isMouseDown && currentTime - player.lastShotTime > player.currentWeapon.fireRate && player.currentWeapon.currentClipBullets > 0 && !player.currentWeapon.isReloading) {
                    createBullet(player, null);
                    player.currentWeapon.currentClipBullets--;
                    
                    if (player.currentWeapon.name === "VE-8" && player.currentWeapon.playerHealthRegen) {
                        player.health = Math.min(player.maxHealth, player.health + player.currentWeapon.playerHealthRegen);
                    }
                    if (player.currentWeapon.name === "F-7" && player.currentWeapon.playerHealthCapIncrease) {
                        player.maxHealth += player.currentWeapon.playerHealthCapIncrease;
                        player.health = Math.min(player.maxHealth, player.health + player.currentWeapon.playerHealthCapIncrease);
                    }

                    updateWeaponUI();
                    player.lastShotTime = currentTime;
                }

                // Handle Player Reloading
                if (player.currentWeapon.isReloading) {
                    if (currentTime - player.currentWeapon.lastReloadTime > player.currentWeapon.reloadTime) {
                        const bulletsToReload = player.currentWeapon.clipSize - player.currentWeapon.currentClipBullets;
                        player.currentWeapon.currentClipBullets += bulletsToReload;
                        player.currentWeapon.isReloading = false;
                        updateWeaponUI();
                    }
                }
            }

            // Generate enemies based on wave logic
            const currentWave = waveDefinitions[currentWaveIndex];
            if (enemiesSpawnedInWave < currentWave.enemyCount && currentTime - lastEnemySpawnTime > (enemySpawnIntervalBase / currentWave.spawnRateMultiplier)) {
                createEnemy();
                enemiesSpawnedInWave++;
                lastEnemySpawnTime = currentTime;
            }

            // Update all bullets (player and enemy)
            const allBullets = [...playerBullets, ...enemyBullets];
            for (let i = allBullets.length - 1; i >= 0; i--) {
                const bullet = allBullets[i];
                if (!bullet || !bullet.mesh) {
                    if (i < playerBullets.length) playerBullets.splice(i, 1);
                    else enemyBullets.splice(i - playerBullets.length, 1);
                    continue;
                }
                bullet.mesh.position.add(bullet.velocity);

                const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);
                let hitObstacle = false;
                if (!bullet.piercing) {
                    for (const obstacle of obstacles) {
                        const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                        if (bulletBox.intersectsBox(obstacleBox)) {
                            hitObstacle = true;
                            break;
                        }
                    }
                }

                if (Math.abs(bullet.mesh.position.x) > 30 || Math.abs(bullet.mesh.position.z) > 30 || Math.abs(bullet.mesh.position.y) > 30 || hitObstacle) {
                    scene.remove(bullet.mesh);
                    if (i < playerBullets.length) playerBullets.splice(i, 1);
                    else enemyBullets.splice(i - playerBullets.length, 1);

                    if (hitObstacle && bullet.explosive) {
                        const impactPosition = bullet.mesh.position.clone();
                        for (const char of allCharacters) {
                            if (char !== bullet.shooter && !char.isDead && !char.isReviving) {
                                if (char.mesh.position.distanceTo(impactPosition) < explosionRadius) {
                                    takeDamage(char, explosionDamage, bullet.shooter);
                                }
                            }
                        }
                    }
                    continue;
                }

                for (let j = allCharacters.length - 1; j >= 0; j--) {
                    const targetCharacter = allCharacters[j];

                    if (targetCharacter.isDead || targetCharacter === bullet.shooter || targetCharacter.isReviving) {
                        continue;
                    }

                    if (bullet.mesh.position.distanceTo(targetCharacter.mesh.position) < 1) {
                        scene.remove(bullet.mesh);
                        if (i < playerBullets.length) playerBullets.splice(i, 1);
                        else enemyBullets.splice(i - playerBullets.length, 1);

                        takeDamage(targetCharacter, bullet.damage, bullet.shooter);

                        if (bullet.explosive) {
                            const impactPosition = bullet.mesh.position.clone();
                            for (const char of allCharacters) {
                                if (char !== bullet.shooter && !char.isDead && !char.isReviving) {
                                    if (char.mesh.position.distanceTo(impactPosition) < explosionRadius) {
                                        takeDamage(char, explosionDamage, bullet.shooter);
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const enemyGroundY = 0.6;
                enemy.velocityY += gravity;
                enemy.mesh.position.y += enemy.velocityY;
                if (enemy.mesh.position.y < enemyGroundY) {
                    enemy.mesh.position.y = enemyGroundY;
                    enemy.velocityY = 0;
                }

                if (enemy.isDead) {
                    continue;
                }

                // Enemy Dash Logic
                if (!enemy.isDashing && currentTime - enemy.lastDashTime > enemy.dashCooldown) {
                    if (Math.random() < 0.015) {
                        enemy.isDashing = true;
                        enemy.dashStartTime = currentTime;
                        enemy.dashDirection.subVectors(player.mesh.position, enemy.mesh.position);
                        enemy.dashDirection.y = 0;
                        enemy.dashDirection.normalize();
                        enemy.lastDashTime = currentTime;
                    }
                }

                if (enemy.isDashing) {
                    const elapsedEnemyDashTime = currentTime - enemy.dashStartTime;
                    if (elapsedEnemyDashTime < enemy.dashDuration) {
                        const dashMoveX = enemy.dashDirection.x * enemy.dashSpeed;
                        const dashMoveZ = enemy.dashDirection.z * enemy.dashSpeed;
                        moveAndCollide(enemy.mesh, dashMoveX, dashMoveZ, obstacles);
                    } else {
                        enemy.isDashing = false;
                    }
                } else {
                    let moveTargetPosition = null;
                    if (enemy.currentTarget && !enemy.currentTarget.isDead && !enemy.currentTarget.isReviving) {
                        moveTargetPosition = enemy.currentTarget.mesh.position;
                    } else {
                        const activeCharactersForMovement = allCharacters.filter(char =>
                            !char.isDead && !char.isReviving && char !== enemy
                        );
                        if (activeCharactersForMovement.length > 0) {
                            let closestChar = null;
                            let minDist = Infinity;
                            for (const char of activeCharactersForMovement) {
                                const dist = enemy.mesh.position.distanceTo(char.mesh.position);
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestChar = char;
                                }
                            }
                            if (closestChar) {
                                enemy.currentTarget = closestChar;
                                moveTargetPosition = closestChar.mesh.position;
                            }
                        }
                    }

                    if (moveTargetPosition) {
                        const directionToTarget = new THREE.Vector3().subVectors(moveTargetPosition, enemy.mesh.position).normalize();
                        const enemyMoveX = directionToTarget.x * 0.05;
                        const enemyMoveZ = directionToTarget.z * 0.05;
                        moveAndCollide(enemy.mesh, enemyMoveX, enemyMoveZ, obstacles);
                    }
                }

                // Enemy Jump and Gravity
                if (currentTime - enemy.lastJumpTime > enemy.jumpInterval && enemy.mesh.position.y <= enemyGroundY + 0.01) {
                    enemy.velocityY = jumpForce * 0.8;
                    enemy.lastJumpTime = currentTime;
                    enemy.jumpInterval = 3000 + Math.random() * 3000;
                }

                enemy.velocityY += gravity;
                enemy.mesh.position.y += enemy.velocityY;

                if (enemy.mesh.position.y < enemyGroundY) {
                    enemy.mesh.position.y = enemyGroundY;
                    enemy.velocityY = 0;
                }

                // Enemy Shooting and Reloading
                if (enemy.currentWeapon.currentClipBullets > 0 && !enemy.currentWeapon.isReloading && currentTime - enemy.lastShotTime > enemy.currentWeapon.fireRate) {
                    const potentialTargets = allCharacters.filter(char =>
                        !char.isDead && !char.isReviving && char !== enemy
                    );

                    let actualShootingTarget = null;
                    for (const char of potentialTargets) {
                        if (isTargetVisible(enemy.mesh.position, char.mesh.position, obstacles)) {
                            actualShootingTarget = char;
                            break;
                        }
                    }

                    if (actualShootingTarget) {
                        enemy.currentTarget = actualShootingTarget;
                        createBullet(enemy, actualShootingTarget.mesh.position);
                        enemy.currentWeapon.currentClipBullets--;
                        enemy.lastShotTime = currentTime;

                        if (enemy.currentWeapon.name === "F-7" && enemy.currentWeapon.enemyHealthRegenPerShot) {
                            enemy.health = Math.min(enemy.maxHealth, enemy.health + enemy.currentWeapon.enemyHealthRegenPerShot);
                        }
                    }
                } else if (enemy.currentWeapon.currentClipBullets === 0 && !enemy.currentWeapon.isReloading) {
                    reloadWeapon(enemy);
                }

                if (enemy.currentWeapon.isReloading) {
                    if (currentTime - enemy.currentWeapon.lastReloadTime > enemy.currentWeapon.reloadTime) {
                        const bulletsToReload = enemy.currentWeapon.clipSize - enemy.currentWeapon.currentClipBullets;
                        enemy.currentWeapon.currentClipBullets += bulletsToReload;
                        enemy.currentWeapon.isReloading = false;
                    }
                }

                const boundary = 28;
                enemy.mesh.position.x = Math.max(-boundary, Math.min(boundary, enemy.mesh.position.x));
                enemy.mesh.position.z = Math.max(-boundary, Math.min(boundary, enemy.mesh.position.z));
            }

            // Check for characters reviving
            allCharacters.forEach(char => {
                if (char.isReviving && currentTime - char.lastDeathTime > reviveDuration) {
                    char.isReviving = false;
                    if (char.type === 'player') {
                        player.mesh.material.visible = false;
                    } else {
                        char.mesh.material.opacity = 1;
                        char.mesh.material.transparent = false;
                    }
                }
            });

            // DR-18 Enemy Vision Logic
            if (player.currentWeapon.enemyVision && player.isAimingDR5) {
                enemies.forEach(enemy => {
                    if (!enemy.isDead && !enemy.isReviving) {
                        if (!enemy.originalMaterial) {
                            enemy.originalMaterial = enemy.mesh.material;
                        }
                        enemy.mesh.material = new THREE.MeshBasicMaterial({ color: 0x00FF33, transparent: true, opacity: 0.4 });
                    }
                });
            } else {
                enemies.forEach(enemy => {
                    if (enemy.originalMaterial && enemy.mesh.material !== enemy.originalMaterial) {
                        enemy.mesh.material = enemy.originalMaterial;
                        enemy.mesh.material.transparent = false;
                        enemy.mesh.material.opacity = 1;
                    }
                });
            }

            updateUI();
        }

        function takeDamage(targetCharacter, amount, damageSource) {
            if (targetCharacter.isDead || targetCharacter.isReviving) {
                return;
            }

            targetCharacter.health -= amount;

            if (targetCharacter.type === 'player') {
                const hitSourcePosition = damageSource.mesh ? damageSource.mesh.position : new THREE.Vector3(0,0,0);
                const hitDirection = new THREE.Vector3().subVectors(hitSourcePosition, player.mesh.position);
                hitDirection.y = 0;
                hitDirection.normalize();

                const playerForward = new THREE.Vector3();
                camera.getWorldDirection(playerForward);
                playerForward.y = 0;
                playerForward.normalize();

                const playerRight = new THREE.Vector3();
                playerRight.crossVectors(playerForward, new THREE.Vector3(0, 1, 0));
                playerRight.normalize();

                const dotFront = hitDirection.dot(playerForward);
                const dotRight = hitDirection.dot(playerRight);

                let indicatorToShow = null;
                const threshold = 0.5;

                if (dotFront > threshold) {
                    indicatorToShow = hitIndicatorFront;
                } else if (dotFront < -threshold) {
                    indicatorToShow = hitIndicatorBack;
                } else if (dotRight > threshold) {
                    indicatorToShow = hitIndicatorRight;
                } else if (dotRight < -threshold) {
                    indicatorToShow = hitIndicatorLeft;
                } else {
                    if (Math.abs(dotFront) > Math.abs(dotRight)) {
                        indicatorToShow = dotFront > 0 ? hitIndicatorFront : hitIndicatorBack;
                    } else {
                        indicatorToShow = dotRight > 0 ? hitIndicatorRight : hitIndicatorLeft;
                    }
                }

                if (indicatorToShow) {
                    indicatorToShow.style.opacity = 1;
                    indicatorToShow.style.display = 'block';
                    setTimeout(() => {
                        indicatorToShow.style.opacity = 0;
                        setTimeout(() => {
                            indicatorToShow.style.display = 'none';
                        }, 100);
                    }, 400);
                }
            }

            if (targetCharacter.health <= 0) {
                targetCharacter.revivesRemaining--;
                if (targetCharacter.revivesRemaining > 0) {
                    targetCharacter.health = targetCharacter.maxHealth;
                    targetCharacter.isReviving = true;
                    targetCharacter.lastDeathTime = Date.now();
                    const respawnPos = getSafeRespawnPosition();
                    targetCharacter.mesh.position.copy(respawnPos);
                    targetCharacter.velocityY = 0;

                    if (targetCharacter.type === 'player') {
                        // Player specific revive effects if any
                    } else {
                        targetCharacter.mesh.material.transparent = true;
                        targetCharacter.mesh.material.opacity = 0.5;
                    }
                } else {
                    console.log(`${targetCharacter.type} is permanently eliminated! Revives remaining: ${targetCharacter.revivesRemaining}`);
                    targetCharacter.isDead = true;

                    if (targetCharacter.mesh.material instanceof THREE.MeshPhongMaterial || targetCharacter.mesh.material instanceof THREE.MeshBasicMaterial) {
                        targetCharacter.mesh.material.color.set(0x333333);
                        targetCharacter.mesh.material.transparent = true;
                        targetCharacter.mesh.material.opacity = 0.3;
                    }

                    if (targetCharacter.type === 'enemy') {
                        enemiesDefeatedInWave++;
                        if (damageSource.type === 'player' && damageSource.currentWeapon.name === 'M-cv7') {
                            damageSource.maxHealth += damageSource.currentWeapon.healthCapIncreaseOnKill;
                            damageSource.health = Math.min(damageSource.maxHealth, damageSource.health + damageSource.currentWeapon.healthCapIncreaseOnKill);
                            
                            damageSource.mcv7Kills++;
                            if (damageSource.mcv7Kills % damageSource.currentWeapon.obstacleOnKillCount === 0) {
                                const tempObstacleGeometry = new THREE.BoxGeometry(3, 3, 3);
                                const tempObstacleMaterial = new THREE.MeshPhongMaterial({ color: 0x00FF00, transparent: true, opacity: 0.7 });
                                const tempObstacle = new THREE.Mesh(tempObstacleGeometry, tempObstacleMaterial);
                                tempObstacle.position.copy(targetCharacter.mesh.position);
                                tempObstacle.position.y = tempObstacle.geometry.parameters.height / 2;
                                scene.add(tempObstacle);
                                temporaryObstacles.push(tempObstacle);
                                obstacles.push(tempObstacle);
                            }
                        }

                        const index = enemies.indexOf(targetCharacter);
                        if (index > -1) {
                            enemies.splice(index, 1);
                        }
                    }
                    checkWinCondition();
                }
            }
            updateUI();
        }

        function createBullet(shooter, targetPosition = null) {
            const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            
            const isSniper = shooter.currentWeapon.name === "M56狙击枪";
            const isUSpray = shooter.currentWeapon.name === "U喷";
            const isVE8 = shooter.currentWeapon.name === "VE-8";
            const isKIRD = shooter.currentWeapon.name === "KIRD";
            const isHV5 = shooter.currentWeapon.name === "HV5";
            const isDR18 = shooter.currentWeapon.name === "DR-18";
            const isMCV7 = shooter.currentWeapon.name === "M-cv7";
            const isF7 = shooter.currentWeapon.name === "F-7";

            const bulletColor = shooter.type === 'player' ? 
                                (isSniper ? 0x800080 : (isVE8 ? 0xFF00FF : (isKIRD ? 0x00FFFF : (isHV5 ? 0xFFA500 : (isDR18 ? 0x4B0082 : (isMCV7 ? 0xFFD700 : (isF7 ? 0xFF4500 : 0xffff00))))))) :
                                0xffa500;

            const bulletMaterial = new THREE.MeshBasicMaterial({ color: bulletColor }); 

            const baseDirection = new THREE.Vector3();
            if (shooter.type === 'player') {
                camera.getWorldDirection(baseDirection);
            } else {
                if (targetPosition) {
                    baseDirection.subVectors(targetPosition, shooter.mesh.position).normalize();
                } else {
                    baseDirection.subVectors(player.mesh.position, shooter.mesh.position).normalize();
                }
            }

            const bulletsToFire = (shooter.currentWeapon.bulletsPerShot && shooter.currentWeapon.name === "U喷") ? shooter.currentWeapon.bulletsPerShot : 1;
            const spreadAngle = (shooter.currentWeapon.spreadAngle && shooter.currentWeapon.name === "U喷") ? shooter.currentWeapon.spreadAngle : 0;
            const bulletsCreated = [];

            for (let i = 0; i < bulletsToFire; i++) {
                const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);

                const shooterPosition = shooter.mesh.position.clone();
                bulletMesh.position.copy(shooterPosition);
                bulletMesh.position.y += 0.5;

                const currentBulletDirection = baseDirection.clone();

                if (isUSpray) {
                    const angleOffset = (i - (bulletsToFire - 1) / 2) * spreadAngle;
                    const axis = new THREE.Vector3(0, 1, 0);
                    currentBulletDirection.applyAxisAngle(axis, angleOffset);
                }

                const bulletVelocity = currentBulletDirection.multiplyScalar(
                    isSniper ? bulletSpeed * 2.5 :
                    (isUSpray ? bulletSpeed * 0.8 :
                    (isVE8 ? bulletSpeed * 1.0 :
                    (isKIRD ? bulletSpeed * 1.0 :
                    (isHV5 ? bulletSpeed * 0.9 :
                    (isDR18 ? bulletSpeed * 2.0 :
                    (isMCV7 ? bulletSpeed * 1.5 :
                    (isF7 ? bulletSpeed * 1.5 :
                    (shooter.currentWeapon.fireRate === 100 ? bulletSpeed * 1.5 : bulletSpeed))))))))
                );

                const bullet = {
                    mesh: bulletMesh,
                    velocity: bulletVelocity,
                    shooter: shooter,
                    damage: shooter.currentWeapon.bulletDamage,
                    piercing: (shooter.type === 'player' && shooter.currentWeapon.playerPiercing) || shooter.currentWeapon.piercing || false,
                    explosive: shooter.currentWeapon.explosive || false
                };

                scene.add(bullet.mesh);
                if (shooter.type === 'player') {
                    playerBullets.push(bullet);
                } else {
                    enemyBullets.push(bullet);
                }
                bulletsCreated.push(bullet);
            }
            return bulletsCreated;
        }

        function createEnemy() {
            const enemyGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const enemyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);

            const weaponChoices = [
                weaponDefinitions.pistol,
                weaponDefinitions.mp5,
                weaponDefinitions.sniper,
                weaponDefinitions.f7,
                weaponDefinitions.kird,
                weaponDefinitions.hv5,
                weaponDefinitions.mcv7
            ].filter(weapon => !weapon.enemyForbidden);
            const randomWeaponDef = weaponChoices[Math.floor(Math.random() * weaponChoices.length)];

            const enemy = {
                mesh: enemyMesh,
                type: 'enemy',
                maxHealth: 100,
                health: 100,
                maxRevives: 3,
                revivesRemaining: 3,
                isDead: false,
                isReviving: false,
                lastDeathTime: 0,
                velocityY: 0,
                lastJumpTime: Date.now(),
                jumpInterval: 3000 + Math.random() * 3000,
                isDashing: false,
                dashStartTime: 0,
                dashDuration: 150,
                dashCooldown: 2000 + Math.random() * 3000,
                lastDashTime: Date.now(),
                dashSpeed: 0.3,
                dashDirection: new THREE.Vector3(),
                currentWeapon: {
                    ...randomWeaponDef,
                    currentClipBullets: randomWeaponDef.clipSize,
                    isReloading: false,
                    lastReloadTime: 0
                },
                lastShotTime: Date.now(),
                currentTarget: null,
                bulletsFiredSinceLastRegen: 0,
                originalMaterial: enemyMaterial
            };

            const respawnPos = getSafeRespawnPosition();
            enemy.mesh.position.copy(respawnPos);
            enemy.mesh.position.y = 0.6;

            scene.add(enemy.mesh);
            enemies.push(enemy);
            allCharacters.push(enemy);
        }

        function reloadWeapon(character) {
            if (character.currentWeapon.isReloading || character.currentWeapon.currentClipBullets === character.currentWeapon.clipSize) {
                return;
            }

            character.currentWeapon.isReloading = true;
            character.currentWeapon.lastReloadTime = Date.now();
            if (character.type === 'player') {
                updateWeaponUI();
            }
        }

        function updateUI() {
            healthDisplay.textContent = `生命值: ${Math.max(0, player.health)} (复活: ${player.revivesRemaining})`;
            scoreDisplay.textContent = `分数: ${score}`;
            const currentWave = waveDefinitions[currentWaveIndex];
            waveDisplay.textContent = `波次: ${currentWave.waveNumber} / ${waveDefinitions.length} (敌人: ${enemiesDefeatedInWave}/${currentWave.enemyCount})`;
        }

        function updateWeaponUI() {
            weaponIcon.src = player.currentWeapon.weaponImage;
            weaponNameDisplay.textContent = player.currentWeapon.name;

            if (player.currentWeapon.isReloading) {
                bulletCountDisplay.textContent = "装弹中...";
            } else {
                bulletCountDisplay.textContent = `${player.currentWeapon.currentClipBullets}/${player.currentWeapon.clipSize} (∞)`;
            }
        }

        function startWave(waveIndex) {
            if (waveIndex >= waveDefinitions.length) {
                gameOver("你成功击败了所有敌人");
                return;
            }

            currentWaveIndex = waveIndex;
            enemiesSpawnedInWave = 0;
            enemiesDefeatedInWave = 0;
            lastEnemySpawnTime = Date.now();

            enemies.length = 0;

            const playerChar = allCharacters.find(char => char.type === 'player');
            allCharacters.length = 0;
            if (playerChar) {
                allCharacters.push(playerChar);
            }

            for (const tempObstacle of temporaryObstacles) {
                scene.remove(tempObstacle);
                const index = obstacles.indexOf(tempObstacle);
                if (index > -1) {
                    obstacles.splice(index, 1);
                }
            }
            temporaryObstacles.length = 0;

            console.log(`--- 开始波次 ${waveDefinitions[currentWaveIndex].waveNumber} ---`);
            updateUI();
        }

        function checkWinCondition() {
            if (player.isDead) {
                gameOver("你被淘汰了");
                return;
            }

            const currentWave = waveDefinitions[currentWaveIndex];
            if (enemiesDefeatedInWave === currentWave.enemyCount) {
                if (currentWaveIndex < waveDefinitions.length - 1) {
                    console.log(`波次 ${currentWave.waveNumber} 完成！`);
                    startWave(currentWaveIndex + 1);
                } else {
                    gameOver("你成功击败了所有敌人");
                }
            }
        }

        function gameOver(statusMessage) {
            isGameOver = true;
            isGamePaused = true;
            document.body.style.cursor = 'auto';

            if (statusMessage === "你被淘汰了") {
                messageText.textContent = `你被淘汰了！游戏结束！你的分数是: ${score}`;
            } else if (statusMessage === "你成功击败了所有敌人") {
                messageText.textContent = `恭喜！你成功击败了所有敌人！你的分数是: ${score}`;
            }
            else {
                messageText.textContent = `游戏结束！${statusMessage} 获胜！你的分数是: ${score}`;
            }

            gameMessage.style.display = 'block';
            console.log("Game Over message displayed. Game message element display style:", gameMessage.style.display);

            playerBullets.forEach(bullet => scene.remove(bullet.mesh));
            playerBullets.length = 0;
            enemyBullets.forEach(bullet => scene.remove(bullet.mesh));
            enemyBullets.length = 0;
        }

        function restartGame() {
            allCharacters.forEach(char => {
                if (char.mesh) {
                    scene.remove(char.mesh);
                }
            });
            allCharacters.length = 0;
            enemies.length = 0;

            playerBullets.forEach(bullet => scene.remove(bullet.mesh));
            playerBullets.length = 0;
            enemyBullets.forEach(bullet => scene.remove(bullet.mesh));
            enemyBullets.length = 0;


            isGameOver = false;
            isGamePaused = false;
            score = 0;
            document.body.style.cursor = 'none';

            player.health = player.maxHealth;
            player.revivesRemaining = player.maxRevives;
            player.isDead = false;
            player.isReviving = false;
            player.mesh.position.set(0, playerGroundY, 0);
            player.mesh.rotation.y = 0;
            camera.rotation.x = 0;
            player.velocityY = 0;
            player.isDashing = false;
            player.dashStartTime = 0;
            player.lastDashTime = 0;
            player.lastShotTime = 0;
            player.currentTarget = null;
            player.isAimingDR5 = false;
            player.bulletsFiredSinceLastRegen = 0;
            player.mcv7Kills = 0;
            if (player.mesh.material instanceof THREE.MeshBasicMaterial) {
                player.mesh.material.visible = false;
            }

            player.playerWeapons = [];
            player.playerWeapons.push({ ...weaponDefinitions.pistol, currentClipBullets: weaponDefinitions.pistol.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.mp5, currentClipBullets: weaponDefinitions.mp5.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.sniper, currentClipBullets: weaponDefinitions.sniper.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.f7, currentClipBullets: weaponDefinitions.f7.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.ve8, currentClipBullets: weaponDefinitions.ve8.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.kird, currentClipBullets: weaponDefinitions.kird.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.hv5, currentClipBullets: weaponDefinitions.hv5.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.dr18, currentClipBullets: weaponDefinitions.dr18.clipSize, isReloading: false, lastReloadTime: 0 });
            player.playerWeapons.push({ ...weaponDefinitions.mcv7, currentClipBullets: weaponDefinitions.mcv7.clipSize, isReloading: false, lastReloadTime: 0 });

            player.selectedWeaponIndex = 0;
            player.currentWeapon = player.playerWeapons[player.selectedWeaponIndex];

            allCharacters.push(player);

            gameMessage.style.display = 'none';
            updateUI();
            updateWeaponUI();
            
            startWave(0);
        }

        const raycaster = new THREE.Raycaster();
        const directionVector = new THREE.Vector3();

        function isTargetVisible(shooterPosition, targetPosition, obstacles) {
            const rayOrigin = shooterPosition.clone();
            rayOrigin.y += 0.5;

            directionVector.subVectors(targetPosition, rayOrigin).normalize();

            raycaster.set(rayOrigin, directionVector);

            const intersects = raycaster.intersectObjects(obstacles, false);

            if (intersects.length > 0) {
                const distanceToFirstObstacle = rayOrigin.distanceTo(intersects[0].point);
                const distanceToTarget = rayOrigin.distanceTo(targetPosition);

                const epsilon = 0.1;
                return distanceToFirstObstacle >= distanceToTarget - epsilon;
            }
            return true;
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>